import _isEmpty from 'lodash/isEmpty';
import _get$1 from 'lodash/get';
import _hasIn from 'lodash/hasIn';
import axios from 'axios';
import Qs from 'qs';
import _extend from 'lodash/extend';
import _isString from 'lodash/isString';
import _isBoolean from 'lodash/isBoolean';
import _isObject from 'lodash/isObject';
import _isNaN from 'lodash/isNaN';
import _isNil from 'lodash/isNil';
import _cloneDeep from 'lodash/cloneDeep';
import { combineReducers, createStore, applyMiddleware } from 'redux';
import { connect, Provider } from 'react-redux';
import thunk from 'redux-thunk';
import _forEach from 'lodash/forEach';
import _head from 'lodash/head';
import _isArray from 'lodash/isArray';
import _pick from 'lodash/pick';
import React, { Component, Fragment } from 'react';
import { Label, Icon, List, Checkbox, Card, Input, Segment, Header, Button, Menu, Loader, Pagination as Pagination$2, Image, Item, Dropdown } from 'semantic-ui-react';
import Overridable from 'react-overridable';
import _ from 'lodash';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var ESRequestSerializer = /*#__PURE__*/function () {
  function ESRequestSerializer() {
    _classCallCheck(this, ESRequestSerializer);

    this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */


  _createClass(ESRequestSerializer, [{
    key: "serialize",
    value: function serialize(stateQuery) {
      var queryString = stateQuery.queryString,
          sortBy = stateQuery.sortBy,
          sortOrder = stateQuery.sortOrder,
          page = stateQuery.page,
          size = stateQuery.size;
      var bodyParams = {};

      if (!_isEmpty(queryString)) {
        bodyParams['query'] = {
          query_string: {
            query: queryString
          }
        };
      }

      if (sortBy) {
        var sortObj = {};
        sortObj[sortBy] = sortOrder && sortOrder === 'desc' ? 'desc' : 'asc';
        bodyParams['sort'] = sortObj;
      }

      if (size > 0) {
        bodyParams['size'] = size;
      }

      if (page > 0) {
        var s = size > 0 ? size : 0;
        var from = (page - 1) * s;
        bodyParams['from'] = from;
      }

      return bodyParams;
    }
  }]);

  return ESRequestSerializer;
}();

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ESResponseSerializer = /*#__PURE__*/function () {
  function ESResponseSerializer() {
    _classCallCheck(this, ESResponseSerializer);

    this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the API backend response for the app state `results`.
   * @param {object} payload the backend response payload
   */


  _createClass(ESResponseSerializer, [{
    key: "serialize",
    value: function serialize(payload) {
      return {
        aggregations: payload.aggregations || {},
        hits: payload.hits.hits.map(function (hit) {
          return hit._source;
        }),
        total: payload.hits.total.value
      };
    }
  }]);

  return ESResponseSerializer;
}();

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var ESSearchApi = /*#__PURE__*/function () {
  function ESSearchApi(config) {
    _classCallCheck(this, ESSearchApi);

    this.axiosConfig = _get$1(config, 'axios', {});
    this.validateAxiosConfig();
    this.initSerializers(config);
    this.initInterceptors(config);
    this.initAxios();
    this.search = this.search.bind(this);
  }

  _createClass(ESSearchApi, [{
    key: "validateAxiosConfig",
    value: function validateAxiosConfig() {
      if (!_hasIn(this.axiosConfig, 'url')) {
        throw new Error('ESSearchApi config: `node` field is required.');
      }
    }
  }, {
    key: "initInterceptors",
    value: function initInterceptors(config) {
      this.requestInterceptor = _get$1(config, 'interceptors.request', undefined);
      this.responseInterceptor = _get$1(config, 'interceptors.response', undefined);
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var requestSerializerCls = _get$1(config, 'es.requestSerializer', ESRequestSerializer);

      var responseSerializerCls = _get$1(config, 'es.responseSerializer', ESResponseSerializer);

      this.requestSerializer = new requestSerializerCls();
      this.responseSerializer = new responseSerializerCls();
    }
  }, {
    key: "initAxios",
    value: function initAxios() {
      this.http = axios.create(this.axiosConfig);
      this.addInterceptors();
    }
  }, {
    key: "addInterceptors",
    value: function addInterceptors() {
      if (this.requestInterceptor) {
        this.http.interceptors.request.use(this.requestInterceptor.resolve, this.requestInterceptor.reject);
      }

      if (this.responseInterceptor) {
        this.http.interceptors.request.use(this.responseInterceptor.resolve, this.responseInterceptor.reject);
      }
    }
    /**
     * Perform the backend request to search and return the serialized list of results for the app state `results`.
     * @param {string} stateQuery the `query` state with the user input
     */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(stateQuery) {
        var payload, response;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                payload = this.requestSerializer.serialize(stateQuery);
                _context.next = 3;
                return this.http.request({
                  method: 'POST',
                  data: payload
                });

              case 3:
                response = _context.sent;
                return _context.abrupt("return", this.responseSerializer.serialize(response.data));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function search(_x) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
  }]);

  return ESSearchApi;
}();

/** Default backend request serializer */

var InvenioRequestSerializer = /*#__PURE__*/function () {
  function InvenioRequestSerializer() {
    var _this = this;

    _classCallCheck(this, InvenioRequestSerializer);

    this._addFilter = function (filter, filterUrlParams) {
      if (!Array.isArray(filter)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array."));
      }

      if (!(filter.length === 2 || filter.length === 3)) {
        throw new Error("Filter value \"".concat(filter, "\" in query state must be an array of 2 or 3 elements"));
      }

      var aggName = filter[0];
      var fieldValue = filter[1];
      filterUrlParams[aggName] = fieldValue;
      var hasChild = filter.length === 3;

      if (hasChild) {
        _this._addFilter(filter[2], filterUrlParams);
      }
    };

    this._addFilters = function (filters) {
      if (!Array.isArray(filters)) {
        throw new Error("Filters query state \"".concat(filters, "\" must be an array."));
      }
      /**
       * input: [
       *   [ 'type_agg', 'value1' ]
       *   [ 'type_agg', 'value2', [ 'subtype_agg', 'a value' ] ]
       * ]
       */


      var filterUrlParams = {};
      filters.forEach(function (filter) {
        _this._addFilter(filter, filterUrlParams);
      });
      /**
       * output: {
       *  type_agg: 'value1'.
       *  subtype_agg: 'a value'
       * }
       */

      return filterUrlParams;
    };

    this.serialize = this.serialize.bind(this);
  }

  _createClass(InvenioRequestSerializer, [{
    key: "serialize",

    /**
     * Return a serialized version of the app state `query` for the API backend.
     * @param {object} stateQuery the `query` state to serialize
     */
    value: function serialize(stateQuery) {
      var queryString = stateQuery.queryString,
          sortBy = stateQuery.sortBy,
          sortOrder = stateQuery.sortOrder,
          page = stateQuery.page,
          size = stateQuery.size,
          filters = stateQuery.filters;
      var getParams = {};

      if (queryString !== null) {
        getParams['q'] = queryString;
      }

      if (sortBy !== null) {
        getParams['sort'] = sortBy;

        if (sortOrder !== null) {
          getParams['sort'] = sortOrder === 'desc' ? "-".concat(sortBy) : sortBy;
        }
      }

      if (page > 0) {
        getParams['page'] = page;
      }

      if (size > 0) {
        getParams['size'] = size;
      }

      var filterParams = this._addFilters(filters);

      _extend(getParams, filterParams);

      return Qs.stringify(getParams, {
        arrayFormat: 'repeat'
      });
    }
  }]);

  return InvenioRequestSerializer;
}();

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

/** Default backend response serializer */
var InvenioResponseSerializer = /*#__PURE__*/function () {
  function InvenioResponseSerializer() {
    _classCallCheck(this, InvenioResponseSerializer);

    this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the API backend response for the app state `results`.
   * @param {object} payload the backend response payload
   */


  _createClass(InvenioResponseSerializer, [{
    key: "serialize",
    value: function serialize(payload) {
      return {
        aggregations: payload.aggregations || {},
        hits: payload.hits.hits,
        total: payload.hits.total
      };
    }
  }]);

  return InvenioResponseSerializer;
}();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var InvenioSearchApi = /*#__PURE__*/function () {
  function InvenioSearchApi(config) {
    _classCallCheck(this, InvenioSearchApi);

    this.axiosConfig = _get$1(config, 'axios', {});
    this.validateAxiosConfig();
    this.initSerializers(config);
    this.initInterceptors(config);
    this.initAxios();
    this.search = this.search.bind(this);
  }

  _createClass(InvenioSearchApi, [{
    key: "validateAxiosConfig",
    value: function validateAxiosConfig() {
      if (!_hasIn(this.axiosConfig, 'url')) {
        throw new Error('InvenioSearchApi config: `url` field is required.');
      }
    }
  }, {
    key: "initInterceptors",
    value: function initInterceptors(config) {
      this.requestInterceptor = _get$1(config, 'interceptors.request', undefined);
      this.responseInterceptor = _get$1(config, 'interceptors.response', undefined);
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var requestSerializerCls = _get$1(config, 'invenio.requestSerializer', InvenioRequestSerializer);

      var responseSerializerCls = _get$1(config, 'invenio.responseSerializer', InvenioResponseSerializer);

      this.requestSerializer = new requestSerializerCls();
      this.responseSerializer = new responseSerializerCls();
    }
  }, {
    key: "initAxios",
    value: function initAxios() {
      var axiosConfig = _objectSpread2({
        paramsSerializer: this.requestSerializer.serialize
      }, this.axiosConfig);

      this.http = axios.create(axiosConfig);
      this.addInterceptors();
    }
  }, {
    key: "addInterceptors",
    value: function addInterceptors() {
      if (this.requestInterceptor) {
        this.http.interceptors.request.use(this.requestInterceptor.resolve, this.requestInterceptor.reject);
      }

      if (this.responseInterceptor) {
        this.http.interceptors.request.use(this.responseInterceptor.resolve, this.responseInterceptor.reject);
      }
    }
    /**
     * Perform the backend request to search and return the serialized list of results for the app state `results`.
     * @param {string} stateQuery the `query` state with the user input
     */

  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(stateQuery) {
        var response;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.http.request({
                  params: stateQuery
                });

              case 2:
                response = _context.sent;
                return _context.abrupt("return", this.responseSerializer.serialize(response.data));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function search(_x) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
  }]);

  return InvenioSearchApi;
}();

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var InvenioSuggestionRequestSerializer = /*#__PURE__*/function () {
  function InvenioSuggestionRequestSerializer(queryField) {
    _classCallCheck(this, InvenioSuggestionRequestSerializer);

    this.queryField = queryField;
    this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */


  _createClass(InvenioSuggestionRequestSerializer, [{
    key: "serialize",
    value: function serialize(stateQuery) {
      var suggestionString = stateQuery.suggestionString;
      var getParams = {};

      if (suggestionString !== null) {
        getParams['q'] = this.queryField + ':' + suggestionString;
      }

      return Qs.stringify(getParams, {
        arrayFormat: 'repeat',
        encode: false
      });
    }
  }]);

  return InvenioSuggestionRequestSerializer;
}();

var InvenioSuggestionResponseSerializer = /*#__PURE__*/function () {
  function InvenioSuggestionResponseSerializer(responseField) {
    var _this = this;

    _classCallCheck(this, InvenioSuggestionResponseSerializer);

    this._serializeSuggestions = function (responseHits) {
      return Array.from(new Set(responseHits.map(function (hit) {
        return _get$1(hit.metadata, _this.responseFieldPath);
      })));
    };

    this.responseFieldPath = responseField.split('.');
    this.serialize = this.serialize.bind(this);
  }

  _createClass(InvenioSuggestionResponseSerializer, [{
    key: "serialize",

    /**
     * Return a serialized version of the API backend response for the app state `suggestions`.
     * @param {object} payload the backend response payload
     */
    value: function serialize(payload) {
      return {
        suggestions: this._serializeSuggestions(payload.hits.hits || [])
      };
    }
  }]);

  return InvenioSuggestionResponseSerializer;
}();

var InvenioSuggestionApi = /*#__PURE__*/function (_InvenioSearchApi) {
  _inherits(InvenioSuggestionApi, _InvenioSearchApi);

  var _super = _createSuper(InvenioSuggestionApi);

  function InvenioSuggestionApi() {
    _classCallCheck(this, InvenioSuggestionApi);

    return _super.apply(this, arguments);
  }

  _createClass(InvenioSuggestionApi, [{
    key: "validateConfig",
    value: function validateConfig(config) {
      _get(_getPrototypeOf(InvenioSuggestionApi.prototype), "validateConfig", this).call(this, config);

      if (!_hasIn(config, 'invenio.suggestions.queryField')) {
        throw new Error('InvenioSuggestionApi config: `invenio.suggestions.queryField` is required.');
      }

      if (!_hasIn(config, 'invenio.suggestions.responseField')) {
        throw new Error('InvenioSuggestionApi config: `invenio.suggestions.queryField` is responseField.');
      }
    }
  }, {
    key: "initSerializers",
    value: function initSerializers(config) {
      var requestSerializerCls = _get$1(config, 'invenio.requestSerializer', InvenioSuggestionRequestSerializer);

      var responseSerializerCls = _get$1(config, 'invenio.responseSerializer', InvenioSuggestionResponseSerializer);

      this.requestSerializer = new requestSerializerCls(config.invenio.suggestions.queryField);
      this.responseSerializer = new responseSerializerCls(config.invenio.suggestions.responseField);
    }
  }]);

  return InvenioSuggestionApi;
}(InvenioSearchApi);

var pushHistory = function pushHistory(query) {
  if (window.history.pushState) {
    window.history.pushState({
      path: query
    }, '', query);
  }
};

var replaceHistory = function replaceHistory(query) {
  if (window.history.replaceState) {
    window.history.replaceState({
      path: query
    }, '', query);
  }
};
/** Default URL parser implementation */


var UrlParser = /*#__PURE__*/function () {
  function UrlParser() {
    _classCallCheck(this, UrlParser);

    this._sanitizeParamValue = function (value) {
      var parsedValue = parseInt(value);

      if (_isNaN(parsedValue)) {
        try {
          var _value = JSON.parse(value);

          if (!_isNil(_value)) {
            parsedValue = _value;
          }
        } catch (e) {
          if (value !== 'undefined') {
            parsedValue = value;
          } else {
            console.error("Cannot parse value ".concat(value, "."));
          }
        }
      }

      return parsedValue;
    };

    this.parse = this.parse.bind(this);
  }

  _createClass(UrlParser, [{
    key: "parse",

    /**
     * Parse the URL query string and return an object with all the params.
     * @param {string} queryString the query string to parse
     */
    value: function parse() {
      var _this = this;

      var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var parsedParams = Qs.parse(queryString, {
        ignoreQueryPrefix: true
      });
      var params = {};
      Object.entries(parsedParams).forEach(function (entry) {
        var key = entry[0];
        var value = entry[1];
        params[key] = _this._sanitizeParamValue(value);
      });
      return params;
    }
  }]);

  return UrlParser;
}();
/** Default implementation for a param validator class */


var UrlParamValidator = function UrlParamValidator() {
  _classCallCheck(this, UrlParamValidator);

  this.isValid = function (key, value) {
    return true;
  };
};
/** Object responsible to update the URL query string and parse it to update the app state */


var UrlHandlerApi = /*#__PURE__*/function () {
  function UrlHandlerApi() {
    var _this2 = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UrlHandlerApi);

    this._filterListToString = function (filter) {
      var childFilter = filter.length === 3 ? _this2.urlFilterSeparator.concat(_this2._filterListToString(filter[2])) : '';
      return "".concat(filter[0], ":").concat(filter[1]).concat(childFilter);
    };

    this._mapQueryStateToUrlParams = function (queryState) {
      var params = {};
      Object.keys(queryState).filter(function (stateKey) {
        return stateKey in _this2.urlParamsMapping;
      }).filter(function (stateKey) {
        // filter out negative or null values
        if ((stateKey === 'page' || stateKey === 'size') && queryState[stateKey] <= 0) {
          return false;
        }

        return queryState[stateKey] !== null;
      }).forEach(function (stateKey) {
        var paramKey = _this2.urlParamsMapping[stateKey];

        if (stateKey === 'filters') {
          params[paramKey] = queryState[stateKey].map(function (filter) {
            return _this2._filterListToString(filter);
          });
        } else {
          params[paramKey] = queryState[stateKey];
        }
      }); // will omit undefined and null values from the query

      return Qs.stringify(params, {
        addQueryPrefix: true,
        skipNulls: true,
        indices: false // order for filters params is not important, remove indices

      });
    };

    this._filterStringToList = function (filterStr) {
      var childSepPos = filterStr.indexOf(_this2.urlFilterSeparator);
      var hasChild = childSepPos > -1;
      var aggNamePos = filterStr.indexOf(':');

      if (aggNamePos === -1) {
        throw new Error("Filter \"".concat(filterStr, "\" not parsable. Format expected: \"<agg name>:<value>\""));
      }

      var aggName = filterStr.slice(0, aggNamePos);
      var end = hasChild ? childSepPos : filterStr.length;
      var value = filterStr.slice(aggNamePos + 1, end);
      var filterList = [aggName, value];

      if (hasChild) {
        var childFilter = filterStr.slice(childSepPos + 1, filterStr.length);
        filterList.push(_this2._filterStringToList(childFilter));
      }

      return filterList;
    };

    this._mapUrlParamsToQueryState = function (urlParamsObj) {
      var result = {};
      Object.keys(urlParamsObj).forEach(function (paramKey) {
        if (_this2.urlParamValidator.isValid(paramKey, urlParamsObj[paramKey])) {
          var queryStateKey = _this2.fromUrlParamsMapping[paramKey];
          result[queryStateKey] = urlParamsObj[paramKey]; // custom transformation for filters

          if (queryStateKey === 'filters') {
            if (!Array.isArray(urlParamsObj[paramKey])) {
              // if only 1 filter, create an array with one element
              urlParamsObj[paramKey] = [urlParamsObj[paramKey]];
            }

            result[queryStateKey] = urlParamsObj[paramKey].map(function (filter) {
              return _this2._filterStringToList(filter);
            });
          }
        }
      });
      return result;
    };

    this._mergeParamsIntoState = function (urlStateObj, queryState) {
      var _queryState = _cloneDeep(queryState);

      Object.keys(urlStateObj).forEach(function (stateKey) {
        if (stateKey in _queryState) {
          _queryState[stateKey] = urlStateObj[stateKey];
        }
      });
      return _queryState;
    };

    this.urlParamsMapping = _isObject(config.urlParamsMapping) ? config.urlParamsMapping : {
      queryString: 'q',
      sortBy: 'sort',
      sortOrder: 'order',
      page: 'p',
      size: 's',
      layout: 'l',
      filters: 'f'
    };
    this.keepHistory = config.keepHistory !== undefined ? config.keepHistory : true;

    if (!_isBoolean(this.keepHistory)) {
      throw new Error("\"keepHistory configuration must be a boolean, ".concat(this.keepHistory, " provided."));
    }

    this.urlFilterSeparator = config.urlFilterSeparator !== undefined ? config.urlFilterSeparator : '+';

    if (!_isString(this.urlFilterSeparator)) {
      throw new Error("\"urlFilterSeparator configuration must be a string, ".concat(this.urlFilterSeparator, " provided."));
    }

    this.urlParamValidator = config.urlParamValidator || new UrlParamValidator();
    this.urlParser = config.urlParser || new UrlParser(); // build the serializer from URL params to Query state by flipping the urlParamsMapping

    this.fromUrlParamsMapping = {};
    Object.keys(this.urlParamsMapping).forEach(function (stateKey) {
      _this2.fromUrlParamsMapping[_this2.urlParamsMapping[stateKey]] = stateKey;
    });
    this.get = this.get.bind(this);
    this.set = this.set.bind(this);
    this.replace = this.replace.bind(this);
  }
  /**
   * Map filters from list to string that is human readable
   * [ 'type', 'photo', [ 'subtype', 'png' ]] => type:photo+subtype:png
   */


  _createClass(UrlHandlerApi, [{
    key: "get",

    /**
     * Return a new version of the given `query` state with updated values parsed from the URL query string.
     * @param {object} queryState the `query` state
     */
    value: function get(queryState) {
      var urlParamsObj = this.urlParser.parse(window.location.search);

      var urlStateObj = this._mapUrlParamsToQueryState(urlParamsObj);

      var newQueryState = this._mergeParamsIntoState(urlStateObj, queryState);

      var newUrlParams = this._mapQueryStateToUrlParams(newQueryState);

      replaceHistory(newUrlParams);
      return newQueryState;
    }
    /**
     * Update the URL query string parameters from the given `query` state
     * @param {object} stateQuery the `query` state
     */

  }, {
    key: "set",
    value: function set(stateQuery) {
      if (this.keepHistory) {
        var newUrlParams = this._mapQueryStateToUrlParams(stateQuery);

        pushHistory(newUrlParams);
      } else {
        this.replace(stateQuery);
      }
    }
    /**
     * Replace the URL query string parameters from the given `query` state
     * @param {object} stateQuery the `query` state
     */

  }, {
    key: "replace",
    value: function replace(stateQuery) {
      var newUrlParams = this._mapQueryStateToUrlParams(stateQuery);

      replaceHistory(newUrlParams);
    }
  }]);

  return UrlHandlerApi;
}();

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var SET_QUERY_COMPONENT_INITIAL_STATE = 'SET_QUERY_COMPONENT_INITIAL_STATE';
var SET_QUERY_STRING = 'SET_QUERY_STRING';
var SET_QUERY_SORTING = 'SET_QUERY_SORTING';
var SET_QUERY_SORT_BY = 'SET_QUERY_SORT_BY';
var SET_QUERY_SORT_ORDER = 'SET_QUERY_SORT_ORDER';
var SET_QUERY_STATE = 'SET_QUERY_STATE';
var SET_QUERY_PAGINATION_PAGE = 'SET_QUERY_PAGINATION_PAGE';
var SET_QUERY_PAGINATION_SIZE = 'SET_QUERY_PAGINATION_SIZE';
var SET_QUERY_FILTERS = 'SET_QUERY_FILTERS';
var SET_QUERY_SUGGESTIONS = 'SET_QUERY_SUGGESTIONS';
var SET_SUGGESTION_STRING = 'SET_SUGGESTION_STRING';
var CLEAR_QUERY_SUGGESTIONS = 'CLEAR_QUERY_SUGGESTIONS';
var RESULTS_LOADING = 'RESULTS_LOADING';
var RESULTS_FETCH_SUCCESS = 'RESULTS_FETCH_SUCCESS';
var RESULTS_FETCH_ERROR = 'RESULTS_FETCH_ERROR';
var RESULTS_UPDATE_LAYOUT = 'RESULTS_UPDATE_LAYOUT';
var RESET_QUERY = 'RESET_QUERY';

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
/**
 * Return true if the first string starts and contains the second.
 * @param {string} first a string
 * @param {string} second a string
 */

function startsWith(first, second) {
  return first.indexOf(second) === 0;
}

function toString(array) {
  return Qs.stringify({
    q: array
  });
}

function parse(str) {
  return Qs.parse(str)['q'];
}

function removeLastChild(arr) {
  var hasChild = arr.length === 3;

  if (hasChild) {
    var result = [arr[0], arr[1]];
    var lastChild = removeLastChild(arr[2]);

    if (lastChild.length) {
      result.push(lastChild);
    }

    return result;
  }

  return [];
}

function updateFilter(queryFilter, stateFilters) {
  /**
   * convert query and state to strings so they can be compared
   */
  var strQuery = toString(queryFilter);
  var strStateFilters = stateFilters.map(function (stateObjQuery) {
    return toString(stateObjQuery);
  });
  /**
   * filter out any state that starts with the query or any parent of the query
   * e.g. query = ['file_type', 'pdf']
   *      state = [[ 'file_type', 'pdf' ]]
   *      filtered = []
   *
   *      query = [ 'type', 'publication' ]
   *      state = [['type', 'publication', ['subtype', 'report' ]]
   *      filtered = []
   *
   *      query = ['type', 'publication', ['subtype', 'report']]]
   *      state = [[ 'type', 'publication' ]]
   *      filtered = []
   */

  var anyRemoved = false;
  var filteredStrStates = strStateFilters.filter(function (strStateFilter) {
    var childFilterExists = startsWith(strStateFilter, strQuery);
    var parentFilterExists = startsWith(strQuery, strStateFilter);

    if (childFilterExists && !anyRemoved) {
      anyRemoved = true;
    }

    return !childFilterExists && !parentFilterExists;
  });

  if (!anyRemoved) {
    /**
     * if nothing has been removed, it means it was not previously there, so
     * the user query has to be added.
     * e.g. query = ['type', 'publication', ['subtype', 'report']]
     *      state = []
     *      filtered = [['type', 'publication', ['subtype', 'report']]]
     */
    filteredStrStates.push(strQuery);
  } else {
    /**
     * if a filter has been removed, it might have been a child. Add its parent if it is the root parent.
     * e.g. query = ['type', 'publication', 'subtype', 'report']
     *      state = [['type', 'publication', ['subtype', 'report']]]
     *      filtered = [['type', 'publication']]
     */
    var hasChild = queryFilter.length === 3;

    if (hasChild) {
      var arr = removeLastChild(queryFilter);
      filteredStrStates.push(toString(arr));
    }
  }
  /**
   * convert back to lists
   */


  return filteredStrStates.map(function (strState) {
    return parse(strState);
  });
}

var updateQueryFilters = function updateQueryFilters(queryFilter, stateFilters) {
  if (_isEmpty(queryFilter)) return;
  /** If we have one filter as query = ['file_type', 'pdf'] */

  if (!_isArray(_head(queryFilter))) {
    return updateFilter(queryFilter, stateFilters);
  }
  /** If we have an array of filters as query we apply the filters one by one.
   * e.g. query = [['file_type', 'pdf'], ['file_type', 'txt']]
   */


  var tempStateFilters = stateFilters;

  _forEach(queryFilter, function (filter) {
    return tempStateFilters = updateFilter(filter, tempStateFilters);
  });

  return tempStateFilters;
};
var updateQueryState = function updateQueryState(oldState, newState, storeKeys) {
  var pickedState = _pick(newState, storeKeys);

  if ('filters' in pickedState) {
    pickedState['filters'] = updateQueryFilters(pickedState.filters, oldState.filters);
  }

  return pickedState;
};

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var INITIAL_STORE_STATE = {
  queryString: '',
  suggestions: [],
  sortBy: null,
  sortOrder: null,
  page: -1,
  size: -1,
  filters: [],
  layout: null
};
var STORE_KEYS = Object.keys(INITIAL_STORE_STATE);

var queryReducer = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case SET_QUERY_STRING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        queryString: action.payload,
        page: 1
      });

    case SET_QUERY_SORTING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortBy: action.payload.sortBy,
        sortOrder: action.payload.sortOrder,
        page: 1
      });

    case SET_QUERY_SORT_BY:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortBy: action.payload,
        page: 1
      });

    case SET_QUERY_SORT_ORDER:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        sortOrder: action.payload,
        page: 1
      });

    case SET_QUERY_PAGINATION_PAGE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        page: action.payload
      });

    case SET_QUERY_PAGINATION_SIZE:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        size: action.payload,
        page: 1
      });

    case SET_QUERY_FILTERS:
      {
        return _objectSpread2(_objectSpread2({}, state), {}, {
          page: 1,
          filters: updateQueryFilters(action.payload, state.filters)
        });
      }

    case SET_QUERY_SUGGESTIONS:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestions: action.payload.suggestions
      });

    case CLEAR_QUERY_SUGGESTIONS:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestions: action.payload.suggestions
      });

    case SET_SUGGESTION_STRING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        suggestionString: action.payload
      });

    case SET_QUERY_COMPONENT_INITIAL_STATE:
      return _objectSpread2(_objectSpread2({}, state), action.payload);

    case SET_QUERY_STATE:
      return _objectSpread2(_objectSpread2({}, state), updateQueryState(state, action.payload, STORE_KEYS));

    case RESULTS_UPDATE_LAYOUT:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        layout: action.payload
      });

    case RESET_QUERY:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        queryString: '',
        page: 1,
        filters: []
      });

    default:
      return state;
  }
});

var resultsReducer = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case RESULTS_LOADING:
      return _objectSpread2(_objectSpread2({}, state), {}, {
        loading: true,
        data: _objectSpread2({}, state.data)
      });

    case RESULTS_FETCH_SUCCESS:
      return {
        loading: false,
        data: _objectSpread2(_objectSpread2({}, state.data), {}, {
          aggregations: action.payload.aggregations,
          hits: action.payload.hits,
          total: action.payload.total
        }),
        error: {}
      };

    case RESULTS_FETCH_ERROR:
      return {
        loading: false,
        data: _objectSpread2(_objectSpread2({}, state.data), {}, {
          aggregations: {},
          hits: [],
          total: 0
        }),
        error: action.payload
      };

    default:
      return state;
  }
});

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var rootReducer = combineReducers({
  query: queryReducer,
  results: resultsReducer
});

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
function configureStore(appConfig) {
  var initialQueryState = INITIAL_STORE_STATE;
  var initialResultsState = {
    loading: appConfig.searchOnInit,
    data: {
      hits: [],
      total: 0,
      aggregations: {}
    },
    error: {}
  }; // configure the initial state

  var preloadedQueryState = appConfig.urlHandlerApi ? appConfig.urlHandlerApi.get(initialQueryState) : initialQueryState;
  var preloadedState = {
    query: preloadedQueryState,
    results: initialResultsState
  };
  return createStore(rootReducer, preloadedState, applyMiddleware(thunk.withExtraArgument(appConfig)));
}

function connectExtended(mapStateToProps, mapDispatchToProps, mergeProps) {
  return connect(mapStateToProps, mapDispatchToProps, mergeProps);
}

var setInitialState = function setInitialState(initialState) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_COMPONENT_INITIAL_STATE,
      payload: initialState
    });
  };
};
var onAppInitialized = function onAppInitialized(searchOnInit) {
  return function (dispatch) {
    if (searchOnInit) {
      dispatch(executeQuery({
        shouldUpdateUrlQueryString: false
      }));
    }
  };
};
var updateQueryString = function updateQueryString(queryString) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_STRING,
      payload: queryString
    });
    dispatch(executeQuery());
  };
};
var updateQuerySorting = function updateQuerySorting(sortByValue, sortOrderValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORTING,
      payload: {
        sortBy: sortByValue,
        sortOrder: sortOrderValue
      }
    });
    dispatch(executeQuery());
  };
};
var updateQuerySortBy = function updateQuerySortBy(sortByValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORT_BY,
      payload: sortByValue
    });
    dispatch(executeQuery());
  };
};
var updateQuerySortOrder = function updateQuerySortOrder(sortOrderValue) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_SORT_ORDER,
      payload: sortOrderValue
    });
    dispatch(executeQuery());
  };
};
var updateQueryPaginationPage = function updateQueryPaginationPage(page) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_PAGINATION_PAGE,
      payload: page
    });
    dispatch(executeQuery());
  };
};
var updateQueryPaginationSize = function updateQueryPaginationSize(size) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_PAGINATION_SIZE,
      payload: size
    });
    dispatch(executeQuery());
  };
};
var updateQueryFilters$1 = function updateQueryFilters(filters) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_FILTERS,
      payload: filters
    });
    dispatch(executeQuery());
  };
};
var updateResultsLayout = function updateResultsLayout(layout) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(dispatch, getState, config) {
      var urlHandlerApi, newStateQuery;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              urlHandlerApi = config.urlHandlerApi;

              if (!urlHandlerApi) {
                _context.next = 8;
                break;
              }

              _context.next = 4;
              return dispatch({
                type: RESULTS_UPDATE_LAYOUT,
                payload: layout
              });

            case 4:
              newStateQuery = getState().query;
              urlHandlerApi.set(newStateQuery);
              _context.next = 9;
              break;

            case 8:
              dispatch({
                type: RESULTS_UPDATE_LAYOUT,
                payload: layout
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
};
var resetQuery = function resetQuery() {
  return function (dispatch) {
    dispatch({
      type: RESET_QUERY
    });
    dispatch(executeQuery());
  };
};
var executeQuery = function executeQuery() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$shouldUpdateUrl = _ref2.shouldUpdateUrlQueryString,
      shouldUpdateUrlQueryString = _ref2$shouldUpdateUrl === void 0 ? true : _ref2$shouldUpdateUrl,
      _ref2$shouldReplaceUr = _ref2.shouldReplaceUrlQueryString,
      shouldReplaceUrlQueryString = _ref2$shouldReplaceUr === void 0 ? false : _ref2$shouldReplaceUr;

  return /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(dispatch, getState, config) {
      var queryState, searchApi, urlHandlerApi, response;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              queryState = _cloneDeep(getState().query);
              searchApi = config.searchApi;
              urlHandlerApi = config.urlHandlerApi;

              if (urlHandlerApi) {
                if (shouldReplaceUrlQueryString) {
                  urlHandlerApi.replace(queryState);
                } else if (shouldUpdateUrlQueryString) {
                  urlHandlerApi.set(queryState);
                }
              }

              dispatch({
                type: RESULTS_LOADING
              });
              _context2.prev = 5;
              _context2.next = 8;
              return searchApi.search(queryState);

            case 8:
              response = _context2.sent;
              dispatch({
                type: RESULTS_FETCH_SUCCESS,
                payload: {
                  aggregations: response.aggregations,
                  hits: response.hits,
                  total: response.total
                }
              });
              _context2.next = 16;
              break;

            case 12:
              _context2.prev = 12;
              _context2.t0 = _context2["catch"](5);
              console.error(_context2.t0);
              dispatch({
                type: RESULTS_FETCH_ERROR,
                payload: _context2.t0
              });

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[5, 12]]);
    }));

    return function (_x4, _x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }();
};
var updateSuggestions = function updateSuggestions(suggestionString) {
  return function (dispatch) {
    dispatch({
      type: SET_SUGGESTION_STRING,
      payload: suggestionString
    });
    dispatch(executeSuggestionQuery());
  };
};
var executeSuggestionQuery = function executeSuggestionQuery() {
  return /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(dispatch, getState, config) {
      var queryState, suggestionApi, response;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              queryState = _cloneDeep(getState().query);
              suggestionApi = config.suggestionApi;
              _context3.prev = 2;
              _context3.next = 5;
              return suggestionApi.search(queryState);

            case 5:
              response = _context3.sent;
              dispatch({
                type: SET_QUERY_SUGGESTIONS,
                payload: {
                  suggestions: response.suggestions
                }
              });
              _context3.next = 12;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](2);
              console.error('Could not load suggestions due to: ' + _context3.t0);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 9]]);
    }));

    return function (_x7, _x8, _x9) {
      return _ref4.apply(this, arguments);
    };
  }();
};
var clearSuggestions = function clearSuggestions() {
  return function (dispatch) {
    dispatch({
      type: CLEAR_QUERY_SUGGESTIONS,
      payload: {
        suggestions: []
      }
    });
  };
};
var updateQueryState$1 = function updateQueryState(queryState) {
  return function (dispatch) {
    dispatch({
      type: SET_QUERY_STATE,
      payload: queryState
    });
    dispatch(executeQuery());
  };
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2020 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

/**
 * Build namespaced unique identifier.
 * @param {string} elementName component element name
 * @param {string} overridableId unique identifier passed as prop to overridable component
 */
function buildUID(elementName, overridableId) {
  return "".concat(elementName).concat(overridableId && ".".concat(overridableId));
}

var ActiveFilters = /*#__PURE__*/function (_Component) {
  _inherits(ActiveFilters, _Component);

  var _super = _createSuper(ActiveFilters);

  function ActiveFilters(props) {
    var _this;

    _classCallCheck(this, ActiveFilters);

    _this = _super.call(this, props);

    _this._getLabel = function (filter) {
      var aggName = filter[0];
      var value = filter[1];
      var currentFilter = [aggName, value];
      var hasChild = filter.length === 3;

      if (hasChild) {
        var _this$_getLabel = _this._getLabel(filter[2]),
            label = _this$_getLabel.label,
            activeFilter = _this$_getLabel.activeFilter;

        value = "".concat(value, ".").concat(label);
        currentFilter.push(activeFilter);
      }

      return {
        label: value,
        activeFilter: currentFilter
      };
    };

    _this.updateQueryFilters = props.updateQueryFilters;
    return _this;
  }

  _createClass(ActiveFilters, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          filters = _this$props.filters,
          overridableId = _this$props.overridableId;
      return !!filters.length && /*#__PURE__*/React.createElement(Element, {
        filters: filters,
        removeActiveFilter: this.updateQueryFilters,
        getLabel: this._getLabel,
        overridableId: overridableId
      });
    }
  }]);

  return ActiveFilters;
}(Component);

ActiveFilters.defaultProps = {
  renderElement: null,
  overridableId: ''
};

var Element = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var filters = props.filters,
      removeActiveFilter = props.removeActiveFilter,
      getLabel = props.getLabel;
  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('ActiveFilters.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(React.Fragment, null, filters.map(function (filter, index) {
    var _getLabel = getLabel(filter),
        label = _getLabel.label,
        activeFilter = _getLabel.activeFilter;

    return /*#__PURE__*/React.createElement(Label, {
      image: true,
      key: index,
      onClick: function onClick() {
        return removeActiveFilter(activeFilter);
      }
    }, label, /*#__PURE__*/React.createElement(Icon, {
      name: "delete"
    }));
  })));
};

var ActiveFiltersComponent = Overridable.component('ActiveFilters', ActiveFilters);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
  return {
    updateQueryFilters: function updateQueryFilters(filter) {
      return dispatch(updateQueryFilters$1(filter));
    }
  };
};

var ActiveFilters$1 = connectExtended(function (state) {
  return {
    filters: state.query.filters
  };
}, mapDispatchToProps)(ActiveFiltersComponent);

var BucketAggregationValues = /*#__PURE__*/function (_Component) {
  _inherits(BucketAggregationValues, _Component);

  var _super = _createSuper(BucketAggregationValues);

  function BucketAggregationValues(props) {
    var _this;

    _classCallCheck(this, BucketAggregationValues);

    _this = _super.call(this, props);

    _this._isSelected = function (aggName, value, selectedFilters) {
      // return True there is at least one filter that has this value
      return selectedFilters.filter(function (filter) {
        return filter[0] === aggName && filter[1] === value;
      }).length >= 1;
    };

    _this.getChildAggCmps = function (bucket, selectedFilters) {
      var hasChildAggregation = _this.childAgg && _this.childAgg['aggName'] in bucket;
      var selectedChildFilters = [];

      if (hasChildAggregation) {
        var childBuckets = bucket[_this.childAgg['aggName']]['buckets'];
        selectedFilters.forEach(function (filter) {
          var isThisAggregation = filter[0] === _this.aggName;
          var isThisValue = filter[1] === bucket.key;
          var hasChild = filter.length === 3;

          if (isThisAggregation && isThisValue && hasChild) {
            selectedChildFilters.push(filter[2]);
          }
        });

        var onFilterClicked = function onFilterClicked(value) {
          _this.onFilterClicked([_this.aggName, bucket.key, value]);
        };

        return /*#__PURE__*/React.createElement(BucketAggregationValues, {
          buckets: childBuckets,
          selectedFilters: selectedChildFilters,
          field: _this.childAgg.field,
          aggName: _this.childAgg.aggName,
          childAgg: _this.childAgg.childAgg,
          onFilterClicked: onFilterClicked
        });
      }

      return null;
    };

    _this.field = props.field;
    _this.aggName = props.aggName;
    _this.childAgg = props.childAgg;
    _this.onFilterClicked = props.onFilterClicked;
    return _this;
  }

  _createClass(BucketAggregationValues, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          buckets = _this$props.buckets,
          selectedFilters = _this$props.selectedFilters,
          overridableId = _this$props.overridableId;
      var valuesCmp = buckets.map(function (bucket) {
        var isSelected = _this2._isSelected(_this2.aggName, bucket.key, selectedFilters);

        var onFilterClicked = function onFilterClicked(value) {
          _this2.onFilterClicked([_this2.aggName, value]);
        };

        var getChildAggCmps = function getChildAggCmps(bucket) {
          return _this2.getChildAggCmps(bucket, selectedFilters);
        };

        return /*#__PURE__*/React.createElement(ValueElement, {
          key: bucket.key,
          bucket: bucket,
          isSelected: isSelected,
          onFilterClicked: onFilterClicked,
          getChildAggCmps: getChildAggCmps,
          overridableId: overridableId
        });
      });
      return /*#__PURE__*/React.createElement(ContainerElement, {
        valuesCmp: valuesCmp,
        overridableId: overridableId
      });
    }
  }]);

  return BucketAggregationValues;
}(Component);

BucketAggregationValues.defaultProps = {
  overridableId: ''
};

var ValueElement = function ValueElement(props) {
  var bucket = props.bucket,
      isSelected = props.isSelected,
      onFilterClicked = props.onFilterClicked,
      getChildAggCmps = props.getChildAggCmps,
      overridableId = props.overridableId;
  var label = "".concat(bucket.key, " (").concat(bucket.doc_count, ")");
  var childAggCmps = getChildAggCmps(bucket);
  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('BucketAggregationValues.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(List.Item, {
    key: bucket.key
  }, /*#__PURE__*/React.createElement(Checkbox, {
    label: label,
    value: bucket.key,
    onClick: function onClick() {
      return onFilterClicked(bucket.key);
    },
    checked: isSelected
  }), childAggCmps));
};

var ContainerElement = function ContainerElement(_ref) {
  var valuesCmp = _ref.valuesCmp,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('BucketAggregationContainer.element', overridableId),
    valuesCmp: valuesCmp
  }, /*#__PURE__*/React.createElement(List, null, valuesCmp));
};

var BucketAggregationValues$1 = Overridable.component('BucketAggregationValues', BucketAggregationValues);

var BucketAggregation = /*#__PURE__*/function (_Component) {
  _inherits(BucketAggregation, _Component);

  var _super = _createSuper(BucketAggregation);

  function BucketAggregation(props) {
    var _this;

    _classCallCheck(this, BucketAggregation);

    _this = _super.call(this, props);

    _this.onFilterClicked = function (filter) {
      _this.updateQueryFilters(filter);
    };

    _this._renderValues = function (resultBuckets, selectedFilters) {
      var overridableId = _this.props.overridableId;
      return /*#__PURE__*/React.createElement(BucketAggregationValues$1, {
        buckets: resultBuckets,
        selectedFilters: selectedFilters,
        field: _this.agg.field,
        aggName: _this.agg.aggName,
        childAgg: _this.agg.childAgg,
        onFilterClicked: _this.onFilterClicked,
        overridableId: overridableId
      });
    };

    _this._getSelectedFilters = function (userSelectionFilters) {
      // get selected filters for this field only
      return userSelectionFilters.filter(function (filter) {
        return filter[0] === _this.agg.aggName;
      });
    };

    _this._getResultBuckets = function (resultsAggregations) {
      // get buckets of this field
      var thisAggs = _get$1(resultsAggregations, _this.agg.aggName, {});

      return 'buckets' in thisAggs ? thisAggs['buckets'] : [];
    };

    _this.title = props.title;
    _this.agg = props.agg;
    _this.updateQueryFilters = props.updateQueryFilters;
    return _this;
  }

  _createClass(BucketAggregation, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          userSelectionFilters = _this$props.userSelectionFilters,
          resultsAggregations = _this$props.resultsAggregations,
          overridableId = _this$props.overridableId;

      var selectedFilters = this._getSelectedFilters(userSelectionFilters);

      var resultBuckets = this._getResultBuckets(resultsAggregations);

      var valuesCmp = resultBuckets.length ? this._renderValues(resultBuckets, selectedFilters) : null;
      return /*#__PURE__*/React.createElement(Element$1, {
        title: this.title,
        containerCmp: valuesCmp,
        overridableId: overridableId
      });
    }
  }]);

  return BucketAggregation;
}(Component);

BucketAggregation.defaultProps = {
  renderValuesContainerElement: null,
  renderValueElement: null,
  overridableId: ''
};

var Element$1 = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var title = props.title,
      containerCmp = props.containerCmp;
  return containerCmp && /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('BucketAggregation.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Card, null, /*#__PURE__*/React.createElement(Card.Content, null, /*#__PURE__*/React.createElement(Card.Header, null, title)), /*#__PURE__*/React.createElement(Card.Content, null, containerCmp)));
};

var BucketAggregationComponent = Overridable.component('BucketAggregation', BucketAggregation);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$1 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryFilters: function updateQueryFilters(filter) {
      return dispatch(updateQueryFilters$1(filter));
    }
  };
};

var BucketAggregation$1 = connectExtended(function (state) {
  return {
    userSelectionFilters: state.query.filters,
    resultsAggregations: state.results.data.aggregations
  };
}, mapDispatchToProps$1)(BucketAggregationComponent);

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".AutoCompleteText{position:relative;z-index:100}.AutoCompleteText .input button,.AutoCompleteText .input input{border:none;border-radius:0}.AutoCompleteText ul{width:100%;position:absolute;list-style-type:none;text-align:left;color:#000;background-color:#fff;margin:0;padding:0;border:1px solid #e0e1e2;border-radius:0 0 .3rem .3rem}.AutoCompleteText ul:before{content:\"\"}.AutoCompleteText li{padding:.3em 1em;cursor:pointer}.AutoCompleteText li:hover{text-decoration:underline;background-color:#e0e1e2;border-radius:.3rem}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9saWIvY29tcG9uZW50cy9BdXRvY29tcGxldGVTZWFyY2hCYXIvQXV0b2NvbXBsZXRlU2VhcmNoQmFyLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQ0UsaUJBQWtCLENBQ2xCLFdBQVksQ0FRZCwrREFDRSxXQUFZLENBQ1osZUFBZ0IsQ0FHbEIscUJBQ0UsVUFBVyxDQUNYLGlCQUFrQixDQUNsQixvQkFBcUIsQ0FDckIsZUFBZ0IsQ0FDaEIsVUFBWSxDQUNaLHFCQUF1QixDQUN2QixRQUFTLENBQ1QsU0FBVSxDQUNWLHdCQUFvQyxDQUNwQyw2QkFBZ0MsQ0FHbEMsNEJBQ0UsVUFBVyxDQUdiLHFCQUNFLGdCQUFrQixDQUNsQixjQUFlLENBR2pCLDJCQUNFLHlCQUEwQixDQUMxQix3QkFBb0MsQ0FDcEMsbUJBQXFCIiwiZmlsZSI6IkF1dG9jb21wbGV0ZVNlYXJjaEJhci5zY3NzIn0= */";
styleInject(css_248z);

var _this2 = undefined;

var AutocompleteSearchBar = /*#__PURE__*/function (_Component) {
  _inherits(AutocompleteSearchBar, _Component);

  var _super = _createSuper(AutocompleteSearchBar);

  function AutocompleteSearchBar(props) {
    var _this;

    _classCallCheck(this, AutocompleteSearchBar);

    _this = _super.call(this, props);

    _this._handleAutocompleteChange = function (suggestionString) {
      if (suggestionString.length >= _this.minCharsToAutocomplete) {
        _this.updateSuggestions(suggestionString);
      }
    };

    _this.onInputChange = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(queryString) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.setState({
                  currentValue: queryString
                });

              case 2:
                _this.handleAutocompleteChange(_this.state.currentValue);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    _this.executeSearch = function () {
      _this.updateQueryString(_this.state.currentValue);
    };

    _this.updateQueryString = _this.props.updateQueryString;
    _this.updateSuggestions = _this.props.debounce ? _.debounce(_this.props.updateSuggestions, _this.props.debounceTime, {
      leading: true
    }) : _this.props.updateSuggestions;
    _this.clearSuggestions = _this.props.clearSuggestions;
    _this.minCharsToAutocomplete = _this.props.minCharsToAutocomplete;
    _this.state = {
      currentValue: _this.props.queryString || ''
    };
    _this.handleAutocompleteChange = props.handleAutocompleteChange || _this._handleAutocompleteChange;
    return _this;
  }

  _createClass(AutocompleteSearchBar, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          placeholder = _this$props.placeholder,
          suggestions = _this$props.suggestions,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(Element$2, {
        placeholder: placeholder,
        queryString: this.state.currentValue,
        querySuggestions: suggestions,
        onInputChange: this.onInputChange,
        executeSearch: this.executeSearch,
        overridableId: overridableId
      });
    }
  }]);

  return AutocompleteSearchBar;
}(Component);

AutocompleteSearchBar.defaultProps = {
  handleAutocompleteChange: null,
  placeholder: 'Type something',
  minCharsToAutocomplete: 3,
  overridableId: ''
};

var AutocompleteSearchBarUncontrolled = function AutocompleteSearchBarUncontrolled(props) {
  return /*#__PURE__*/React.createElement(AutocompleteSearchBar, Object.assign({
    key: props.queryString
  }, props));
};

var Element$2 = function Element(_ref2) {
  var overridableId = _ref2.overridableId,
      props = _objectWithoutProperties(_ref2, ["overridableId"]);

  var placeholder = props.placeholder,
      queryString = props.queryString,
      querySuggestions = props.querySuggestions,
      onInputChange = props.onInputChange,
      executeSearch = props.executeSearch;

  var onBtnSearchClick = function onBtnSearchClick(event, input) {
    executeSearch();
  };

  var onKeyPress = function onKeyPress(event, input) {
    if (event.key === 'Enter') {
      executeSearch();
    }
  };

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('AutocompleteSearchBar.element', overridableId)
  }, props), /*#__PURE__*/React.createElement("div", {
    className: "AutoCompleteText"
  }, /*#__PURE__*/React.createElement(Input, {
    action: {
      content: 'Search',
      onClick: onBtnSearchClick
    },
    fluid: true,
    placeholder: placeholder,
    onChange: function onChange(event, _ref3) {
      var value = _ref3.value;
      onInputChange(value);
    },
    value: queryString,
    onKeyPress: onKeyPress
  }), /*#__PURE__*/React.createElement(Suggestions, {
    querySuggestions: querySuggestions,
    overridableId: overridableId
  })));
};

var Suggestions = function Suggestions(_ref4) {
  var overridableId = _ref4.overridableId,
      props = _objectWithoutProperties(_ref4, ["overridableId"]);

  var querySuggestions = props.querySuggestions;

  var onSuggestionSelected = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(suggestion) {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this2.setState({
                currentValue: suggestion
              });

            case 2:
              _this2.clearSuggestions();

              _this2.executeSearch();

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function onSuggestionSelected(_x2) {
      return _ref5.apply(this, arguments);
    };
  }();

  if (querySuggestions.length === 0) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('AutocompleteSearchBar.suggestions', overridableId)
  }, props), /*#__PURE__*/React.createElement("ul", null, querySuggestions.map(function (text) {
    return /*#__PURE__*/React.createElement("li", {
      onClick: function onClick() {
        return onSuggestionSelected(text);
      },
      key: text
    }, text);
  })));
};

var AutocompleteSearchBarComponent = Overridable.component('AutocompleteSearchBar', AutocompleteSearchBarUncontrolled);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$2 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryString: function updateQueryString$1(query) {
      return dispatch(updateQueryString(query));
    },
    updateSuggestions: function updateSuggestions$1(query) {
      return dispatch(updateSuggestions(query));
    },
    clearSuggestions: function clearSuggestions$1() {
      return dispatch(clearSuggestions());
    }
  };
};

var mapStateToProps = function mapStateToProps(state) {
  return {
    queryString: state.query.queryString,
    suggestions: state.query.suggestions
  };
};

var AutocompleteSearchBar$1 = connectExtended(mapStateToProps, mapDispatchToProps$2)(AutocompleteSearchBarComponent);

var ShouldRender = /*#__PURE__*/function (_Component) {
  _inherits(ShouldRender, _Component);

  var _super = _createSuper(ShouldRender);

  function ShouldRender() {
    _classCallCheck(this, ShouldRender);

    return _super.apply(this, arguments);
  }

  _createClass(ShouldRender, [{
    key: "render",
    value: function render() {
      var condition = this.props.condition;
      return condition ? this.props.children : null;
    }
  }]);

  return ShouldRender;
}(Component);

ShouldRender.defaultProps = {
  condition: true
};
var ShouldRender$1 = Overridable.component('ShouldRender', ShouldRender);

var Count = /*#__PURE__*/function (_Component) {
  _inherits(Count, _Component);

  var _super = _createSuper(Count);

  function Count() {
    _classCallCheck(this, Count);

    return _super.apply(this, arguments);
  }

  _createClass(Count, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          label = _this$props.label,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: !loading && totalResults > 0
      }, label( /*#__PURE__*/React.createElement(Element$3, {
        totalResults: totalResults,
        overridableId: overridableId
      })));
    }
  }]);

  return Count;
}(Component);

Count.defaultProps = {
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ''
};

var Element$3 = function Element(_ref) {
  var totalResults = _ref.totalResults,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('Count.element', overridableId),
    totalResults: totalResults
  }, /*#__PURE__*/React.createElement(Label, {
    color: 'blue'
  }, totalResults));
};

var CountComponent = Overridable.component('Count', Count);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var Count$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
})(CountComponent);

var EmptyResults = /*#__PURE__*/function (_Component) {
  _inherits(EmptyResults, _Component);

  var _super = _createSuper(EmptyResults);

  function EmptyResults(props) {
    var _this;

    _classCallCheck(this, EmptyResults);

    _this = _super.call(this, props);
    _this.resetQuery = props.resetQuery;
    return _this;
  }

  _createClass(EmptyResults, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          error = _this$props.error,
          queryString = _this$props.queryString,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: !loading && _isEmpty(error) && totalResults === 0
      }, /*#__PURE__*/React.createElement(Element$4, {
        queryString: queryString,
        resetQuery: this.resetQuery,
        overridableId: overridableId
      }));
    }
  }]);

  return EmptyResults;
}(Component);

EmptyResults.defaultProps = {
  queryString: '',
  overridableId: ''
};

var Element$4 = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var queryString = props.queryString,
      resetQuery = props.resetQuery;
  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('EmptyResults.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Segment, {
    placeholder: true,
    textAlign: "center"
  }, /*#__PURE__*/React.createElement(Header, {
    icon: true
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "search"
  }), "No results found!"), queryString && /*#__PURE__*/React.createElement("em", null, "Current search \"", queryString, "\""), /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement(Button, {
    primary: true,
    onClick: function onClick() {
      return resetQuery();
    }
  }, "Clear query")));
};

var EmptyResultsComponent = Overridable.component('EmptyResults', EmptyResults);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$3 = function mapDispatchToProps(dispatch) {
  return {
    resetQuery: function resetQuery$1() {
      return dispatch(resetQuery());
    }
  };
};

var EmptyResults$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    error: state.results.error,
    queryString: state.query.queryString
  };
}, mapDispatchToProps$3)(EmptyResultsComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

function Error$1(_ref) {
  var loading = _ref.loading,
      error = _ref.error,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(ShouldRender$1, {
    condition: !loading && !_isEmpty(error)
  }, /*#__PURE__*/React.createElement(Element$5, {
    error: error,
    overridableId: overridableId
  }));
}

Error$1.defaultProps = {
  overridableId: ''
};

var Element$5 = function Element(_ref2) {
  var error = _ref2.error,
      overridableId = _ref2.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('Error.element', overridableId),
    error: error
  }, /*#__PURE__*/React.createElement("div", null, "Oups! Something went wrong while fetching results."));
};

var ErrorComponent = Overridable.component('Error', Error$1);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var Error$2 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    error: state.results.error
  };
})(ErrorComponent);

var LayoutSwitcher = /*#__PURE__*/function (_Component) {
  _inherits(LayoutSwitcher, _Component);

  var _super = _createSuper(LayoutSwitcher);

  function LayoutSwitcher(props) {
    var _this;

    _classCallCheck(this, LayoutSwitcher);

    _this = _super.call(this, props);

    _this.onLayoutChange = function (layoutName) {
      _this.updateLayout(layoutName);
    };

    _this.defaultValue = _this.props.defaultLayout;
    _this.updateLayout = props.updateLayout;
    _this.setInitialState = props.setInitialState;
    return _this;
  }

  _createClass(LayoutSwitcher, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentLayout === null) {
        this.setInitialState({
          layout: this.defaultValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentLayout = _this$props.currentLayout,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: currentLayout !== null && !loading && totalResults > 0
      }, /*#__PURE__*/React.createElement(Element$6, {
        currentLayout: currentLayout,
        onLayoutChange: this.onLayoutChange,
        overridableId: overridableId
      }));
    }
  }]);

  return LayoutSwitcher;
}(Component);

LayoutSwitcher.defaultProps = {
  defaultLayout: 'list',
  currentLayout: null,
  overridableId: ''
};

var Element$6 = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentLayout = props.currentLayout,
      onLayoutChange = props.onLayoutChange;

  var clickHandler = function clickHandler(event, _ref2) {
    var name = _ref2.name;
    onLayoutChange(name);
  };

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('LayoutSwitcher.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Menu, {
    compact: true,
    icon: true
  }, /*#__PURE__*/React.createElement(Menu.Item, {
    name: "list",
    active: currentLayout === 'list',
    onClick: clickHandler
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "list layout"
  })), /*#__PURE__*/React.createElement(Menu.Item, {
    name: "grid",
    active: currentLayout === 'grid',
    onClick: clickHandler
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "grid layout"
  }))));
};

var LayoutSwitcherComponent = Overridable.component('LayoutSwitcher', LayoutSwitcher);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$4 = function mapDispatchToProps(dispatch) {
  return {
    updateLayout: function updateLayout(layout) {
      return dispatch(updateResultsLayout(layout));
    },
    setInitialState: function setInitialState$1(initialState) {
      return dispatch(setInitialState(initialState));
    }
  };
};

var LayoutSwitcher$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    currentLayout: state.query.layout,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$4)(LayoutSwitcherComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

function ResultsLoader(_ref) {
  var children = _ref.children,
      loading = _ref.loading,
      overridableId = _ref.overridableId;
  return loading ? /*#__PURE__*/React.createElement(Element$7, {
    overridableId: overridableId
  }) : children;
}

ResultsLoader.defaultProps = {
  overridableId: ''
};

var Element$7 = function Element(_ref2) {
  var overridableId = _ref2.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('ResultsLoader.element', overridableId)
  }, /*#__PURE__*/React.createElement(Loader, {
    active: true,
    size: "huge",
    inline: "centered"
  }));
};

var ResultsLoaderComponent = Overridable.component('ResultsLoader', ResultsLoader);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsLoader$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading
  };
})(ResultsLoaderComponent);

var Pagination = /*#__PURE__*/function (_Component) {
  _inherits(Pagination, _Component);

  var _super = _createSuper(Pagination);

  function Pagination(props) {
    var _this;

    _classCallCheck(this, Pagination);

    _this = _super.call(this, props);

    _this.onPageChange = function (activePage) {
      if (activePage === _this.props.currentPage) return;

      _this.updateQueryPage(activePage);
    };

    _this.defaultValue = props.defaultValue;
    _this.updateQueryPage = props.updateQueryPage;
    _this.setInitialState = props.setInitialState;
    return _this;
  }

  _createClass(Pagination, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentPage === -1) {
        this.setInitialState({
          page: this.defaultValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          currentPage = _this$props.currentPage,
          currentSize = _this$props.currentSize,
          options = _this$props.options,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: !loading && currentPage > -1 && currentSize > -1 && totalResults > 0
      }, /*#__PURE__*/React.createElement(Element$8, {
        currentPage: currentPage,
        currentSize: currentSize,
        totalResults: totalResults,
        onPageChange: this.onPageChange,
        options: options,
        overridableId: overridableId
      }));
    }
  }]);

  return Pagination;
}(Component);

Pagination.defaultProps = {
  options: {
    boundaryRangeCount: 1,
    siblingRangeCount: 1,
    showEllipsis: true,
    showFirst: true,
    showLast: true,
    showPrev: true,
    showNext: true
  },
  defaultValue: 10,
  overridableId: ''
};

var Element$8 = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentPage = props.currentPage,
      currentSize = props.currentSize,
      totalResults = props.totalResults,
      onPageChange = props.onPageChange,
      options = props.options,
      extraParams = _objectWithoutProperties(props, ["currentPage", "currentSize", "totalResults", "onPageChange", "options"]);

  var pages = Math.ceil(totalResults / currentSize);
  var boundaryRangeCount = options.boundaryRangeCount;
  var siblingRangeCount = options.siblingRangeCount;
  var showEllipsis = options.showEllipsis;
  var showFirst = options.showFirst;
  var showLast = options.showLast;
  var showPrev = options.showPrev;
  var showNext = options.showNext;

  var _onPageChange = function _onPageChange(event, _ref2) {
    var activePage = _ref2.activePage;
    onPageChange(activePage);
  };

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('Pagination.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Pagination$2, Object.assign({
    activePage: currentPage,
    totalPages: pages,
    onPageChange: _onPageChange,
    boundaryRange: boundaryRangeCount,
    siblingRange: siblingRangeCount,
    ellipsisItem: showEllipsis ? undefined : null,
    firstItem: showFirst ? undefined : null,
    lastItem: showLast ? undefined : null,
    prevItem: showPrev ? undefined : null,
    nextItem: showNext ? undefined : null
  }, extraParams)));
};

var PaginationComponent = Overridable.component('Pagination', Pagination);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$5 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryPage: function updateQueryPage(page) {
      return dispatch(updateQueryPaginationPage(page));
    },
    setInitialState: function setInitialState$1(value) {
      return dispatch(setInitialState(value));
    }
  };
};

var Pagination$1 = connectExtended(function (state) {
  return {
    currentPage: state.query.page,
    currentSize: state.query.size,
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$5)(PaginationComponent);

var Bootstrap = /*#__PURE__*/function (_Component) {
  _inherits(Bootstrap, _Component);

  var _super = _createSuper(Bootstrap);

  function Bootstrap(props) {
    var _this;

    _classCallCheck(this, Bootstrap);

    _this = _super.call(this, props);

    _this.updateQueryState = function (query) {
      return _this.props.updateQueryState(query);
    };

    _this.onQueryChanged = function (_ref) {
      var payload = _ref.detail;
      var appReceiverName = payload.appName || _this.appName;

      if (appReceiverName === _this.appName) {
        _this.updateQueryState(payload.searchQuery);
      } else {
        console.debug("RSK app ".concat(_this.appName, ": ignore event sent for app ").concat(appReceiverName, "..."));
      }
    };

    _this.appName = props.appName;
    _this.searchOnInit = props.searchOnInit;
    _this.eventListenerEnabled = props.eventListenerEnabled;
    _this.onAppInitialized = props.onAppInitialized;
    _this.searchOnUrlQueryStringChanged = props.searchOnUrlQueryStringChanged;
    return _this;
  }

  _createClass(Bootstrap, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      if (this.eventListenerEnabled) {
        window.addEventListener('queryChanged', this.onQueryChanged);
      }

      window.onpopstate = function () {
        _this2.searchOnUrlQueryStringChanged();
      };

      this.onAppInitialized(this.searchOnInit);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement(Fragment, null, this.props.children);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.historyUnlisten && this.historyUnlisten();

      window.onpopstate = function () {};

      window.removeEventListener('queryChanged', this.onQueryChanged);
    }
  }]);

  return Bootstrap;
}(Component);

Bootstrap.defaultProps = {
  searchOnInit: true
};
var BootstrapComponent = Overridable.component('Bootstrap', Bootstrap);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$6 = function mapDispatchToProps(dispatch) {
  return {
    onAppInitialized: function onAppInitialized$1(searchOnInit) {
      return dispatch(onAppInitialized(searchOnInit));
    },
    updateQueryState: function updateQueryState(queryState) {
      return dispatch(updateQueryState$1(queryState));
    },
    searchOnUrlQueryStringChanged: function searchOnUrlQueryStringChanged() {
      return dispatch(executeQuery({
        shouldUpdateUrlQueryString: false
      }));
    }
  };
};

var Bootstrap$1 = connectExtended(null, mapDispatchToProps$6)(BootstrapComponent);

var ReactSearchKit = /*#__PURE__*/function (_Component) {
  _inherits(ReactSearchKit, _Component);

  var _super = _createSuper(ReactSearchKit);

  function ReactSearchKit(props) {
    var _this;

    _classCallCheck(this, ReactSearchKit);

    _this = _super.call(this, props);
    var appConfig = {
      searchApi: props.searchApi,
      suggestionApi: props.suggestionApi,
      urlHandlerApi: props.urlHandlerApi.enabled ? props.urlHandlerApi.customHandler || new UrlHandlerApi(props.urlHandlerApi.overrideConfig) : null,
      defaultSortByOnEmptyQuery: props.defaultSortByOnEmptyQuery,
      searchOnInit: props.searchOnInit
    };
    _this.store = configureStore(appConfig);
    _this.appName = props.appName;
    _this.eventListenerEnabled = props.eventListenerEnabled;
    return _this;
  }

  _createClass(ReactSearchKit, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          searchOnInit = _this$props.searchOnInit,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(Provider, {
        store: this.store
      }, /*#__PURE__*/React.createElement(Bootstrap$1, {
        searchOnInit: searchOnInit,
        appName: this.appName,
        eventListenerEnabled: this.eventListenerEnabled
      }, /*#__PURE__*/React.createElement(Overridable, {
        id: buildUID('ReactSearchKit.children', overridableId)
      }, this.props.children)));
    }
  }]);

  return ReactSearchKit;
}(Component);
ReactSearchKit.defaultProps = {
  suggestionApi: null,
  urlHandlerApi: {
    enabled: true,
    overrideConfig: {},
    customHandler: null
  },
  searchOnInit: true,
  defaultSortByOnEmptyQuery: null,
  appName: 'RSK',
  eventListenerEnabled: false,
  overridableId: ''
};
var ReactSearchKit$1 = Overridable.component('ReactSearchKit', ReactSearchKit);

function ResultsGrid(_ref) {
  var loading = _ref.loading,
      totalResults = _ref.totalResults,
      results = _ref.results,
      resultsPerRow = _ref.resultsPerRow,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(ShouldRender$1, {
    condition: !loading && totalResults > 0
  }, /*#__PURE__*/React.createElement(Element$9, {
    results: results,
    resultsPerRow: resultsPerRow,
    overridableId: overridableId
  }));
}

ResultsGrid.defaultProps = {
  resultsPerRow: 3,
  overridableId: ''
};

var GridItem = function GridItem(_ref2) {
  var result = _ref2.result,
      index = _ref2.index,
      overridableId = _ref2.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('ResultsGrid.item', overridableId),
    result: result,
    index: index
  }, /*#__PURE__*/React.createElement(Card, {
    fluid: true,
    key: index,
    href: "#".concat(result.id)
  }, /*#__PURE__*/React.createElement(Image, {
    src: result.imgSrc || 'http://placehold.it/200'
  }), /*#__PURE__*/React.createElement(Card.Content, null, /*#__PURE__*/React.createElement(Card.Header, null, result.title), /*#__PURE__*/React.createElement(Card.Description, null, result.description))));
};

var Element$9 = function Element(_ref3) {
  var overridableId = _ref3.overridableId,
      props = _objectWithoutProperties(_ref3, ["overridableId"]);

  var results = props.results,
      resultsPerRow = props.resultsPerRow;

  var _results = results.map(function (result, index) {
    return /*#__PURE__*/React.createElement(GridItem, {
      key: index,
      result: result,
      index: index,
      overridableId: overridableId
    });
  });

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('ResultsGrid.container', overridableId)
  }, props), /*#__PURE__*/React.createElement(Card.Group, {
    itemsPerRow: resultsPerRow
  }, _results));
};

var ResultsGridComponent = Overridable.component('ResultsGrid', ResultsGrid);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsGrid$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    results: state.results.data.hits
  };
})(ResultsGridComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

function ResultsList(_ref) {
  var loading = _ref.loading,
      totalResults = _ref.totalResults,
      results = _ref.results,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(ShouldRender$1, {
    condition: !loading && totalResults > 0
  }, /*#__PURE__*/React.createElement(Element$a, {
    results: results,
    overridableId: overridableId
  }));
}

ResultsList.defaultProps = {
  overridableId: ''
};

var ListItem = function ListItem(_ref2) {
  var result = _ref2.result,
      index = _ref2.index,
      overridableId = _ref2.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('ResultsList.item', overridableId),
    result: result,
    index: index
  }, /*#__PURE__*/React.createElement(Item, {
    key: index,
    href: "#".concat(result.id)
  }, /*#__PURE__*/React.createElement(Item.Image, {
    size: "small",
    src: result.imgSrc || 'http://placehold.it/200'
  }), /*#__PURE__*/React.createElement(Item.Content, null, /*#__PURE__*/React.createElement(Item.Header, null, result.title), /*#__PURE__*/React.createElement(Item.Description, null, result.description))));
};

var Element$a = function Element(_ref3) {
  var results = _ref3.results,
      overridableId = _ref3.overridableId;

  var _results = results.map(function (result, index) {
    return /*#__PURE__*/React.createElement(ListItem, {
      result: result,
      index: index,
      key: index,
      overridableId: overridableId
    });
  });

  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('ResultsList.container', overridableId),
    results: _results
  }, /*#__PURE__*/React.createElement(Item.Group, {
    divided: true,
    relaxed: true,
    link: true
  }, _results));
};

var ResultsListComponent = Overridable.component('ResultsList', ResultsList);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsList$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    results: state.results.data.hits
  };
})(ResultsListComponent);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018-2019 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

function ResultsMultiLayout(_ref) {
  var loading = _ref.loading,
      totalResults = _ref.totalResults,
      currentLayout = _ref.currentLayout,
      overridableId = _ref.overridableId;
  return /*#__PURE__*/React.createElement(ShouldRender$1, {
    condition: currentLayout != null && !loading && totalResults > 0
  }, /*#__PURE__*/React.createElement(Element$b, {
    layout: currentLayout,
    overridableId: overridableId
  }));
}

ResultsMultiLayout.defaultProps = {
  currentLayout: null,
  overridableId: ''
};

var Element$b = function Element(_ref2) {
  var layout = _ref2.layout,
      overridableId = _ref2.overridableId;
  return /*#__PURE__*/React.createElement(Overridable, {
    id: buildUID('ResultsMultiLayout.element', overridableId),
    layout: layout,
    ResultsList: ResultsList$1,
    ResultsGrid: ResultsGrid$1
  }, layout === 'list' ? /*#__PURE__*/React.createElement(ResultsList$1, {
    overridableId: overridableId
  }) : /*#__PURE__*/React.createElement(ResultsGrid$1, {
    overridableId: overridableId
  }));
};

var ResultsMultiLayoutComponent = Overridable.component('ResultsMultiLayout', ResultsMultiLayout);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */
var ResultsMultiLayout$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentLayout: state.query.layout
  };
})(ResultsMultiLayoutComponent);

var ResultsPerPage = /*#__PURE__*/function (_Component) {
  _inherits(ResultsPerPage, _Component);

  var _super = _createSuper(ResultsPerPage);

  function ResultsPerPage(props) {
    var _this;

    _classCallCheck(this, ResultsPerPage);

    _this = _super.call(this, props);

    _this.onChange = function (value) {
      if (value === _this.props.currentSize) return;

      _this.updateQuerySize(value);
    };

    _this.options = props.values;
    _this.defaultValue = props.defaultValue;
    _this.updateQuerySize = _this.props.updateQuerySize;
    _this.setInitialState = props.setInitialState;
    return _this;
  }

  _createClass(ResultsPerPage, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentSize === -1) {
        this.setInitialState({
          size: this.defaultValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          loading = _this$props.loading,
          currentSize = _this$props.currentSize,
          totalResults = _this$props.totalResults,
          label = _this$props.label,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: !loading && totalResults > 0 && currentSize !== -1
      }, label( /*#__PURE__*/React.createElement(Element$c, {
        currentSize: currentSize,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId
      })));
    }
  }]);

  return ResultsPerPage;
}(Component);

ResultsPerPage.defaultProps = {
  defaultValue: 10,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ''
};

var Element$c = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentSize = props.currentSize,
      options = props.options,
      onValueChange = props.onValueChange;

  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('ResultsPerPage.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Dropdown, {
    inline: true,
    compact: true,
    options: _options,
    value: currentSize,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    }
  }));
};

var ResultsPerPageComponent = Overridable.component('ResultsPerPage', ResultsPerPage);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$7 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySize: function updateQuerySize(size) {
      return dispatch(updateQueryPaginationSize(size));
    },
    setInitialState: function setInitialState$1(value) {
      return dispatch(setInitialState(value));
    }
  };
};

var ResultsPerPage$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    currentSize: state.query.size,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$7)(ResultsPerPageComponent);

var SearchBar = /*#__PURE__*/function (_Component) {
  _inherits(SearchBar, _Component);

  var _super = _createSuper(SearchBar);

  function SearchBar(props) {
    var _this;

    _classCallCheck(this, SearchBar);

    _this = _super.call(this, props);

    _this.onInputChange = function (queryString) {
      _this.setState({
        currentValue: queryString
      });
    };

    _this.executeSearch = function () {
      _this.updateQueryString(_this.state.currentValue);
    };

    _this.updateQueryString = _this.props.updateQueryString;
    _this.state = {
      currentValue: _this.props.queryString || ''
    };
    return _this;
  }

  _createClass(SearchBar, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          placeholder = _this$props.placeholder,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(Element$d, {
        placeholder: placeholder,
        queryString: this.state.currentValue,
        onInputChange: this.onInputChange,
        executeSearch: this.executeSearch,
        overridableId: overridableId
      });
    }
  }]);

  return SearchBar;
}(Component);

SearchBar.defaultProps = {
  placeholder: '',
  queryString: '',
  overridableId: ''
};

var SearchBarUncontrolled = function SearchBarUncontrolled(props) {
  return /*#__PURE__*/React.createElement(SearchBar, Object.assign({
    key: props.queryString
  }, props));
};

var Element$d = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var passedPlaceholder = props.placeholder,
      queryString = props.queryString,
      onInputChange = props.onInputChange,
      executeSearch = props.executeSearch;
  var placeholder = passedPlaceholder || 'Type something';

  var onBtnSearchClick = function onBtnSearchClick(event, input) {
    executeSearch();
  };

  var onKeyPress = function onKeyPress(event, input) {
    if (event.key === 'Enter') {
      executeSearch();
    }
  };

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('SearchBar.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Input, {
    action: {
      content: 'Search',
      onClick: onBtnSearchClick
    },
    fluid: true,
    placeholder: placeholder,
    onChange: function onChange(event, _ref2) {
      var value = _ref2.value;
      onInputChange(value);
    },
    value: queryString,
    onKeyPress: onKeyPress
  }));
};

var SearchBarComponent = Overridable.component('SearchBar', SearchBarUncontrolled);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$8 = function mapDispatchToProps(dispatch) {
  return {
    updateQueryString: function updateQueryString$1(query) {
      return dispatch(updateQueryString(query));
    }
  };
};

var SearchBar$1 = connectExtended(function (state) {
  return {
    queryString: state.query.queryString
  };
}, mapDispatchToProps$8)(SearchBarComponent);

var Sort = /*#__PURE__*/function (_Component) {
  _inherits(Sort, _Component);

  var _super = _createSuper(Sort);

  function Sort(props) {
    var _this;

    _classCallCheck(this, Sort);

    _this = _super.call(this, props);

    _this._computeValue = function (sortBy, sortOrder) {
      return "".concat(sortBy, "-").concat(sortOrder);
    };

    _this.onChange = function (value) {
      if (value === _this._computeValue(_this.props.currentSortBy, _this.props.currentSortOrder)) return;

      var selected = _this.options.find(function (option) {
        return option.value === value;
      });

      _this.updateQuerySorting(selected.sortBy, selected.sortOrder);
    };

    _this.options = props.values;
    _this.updateQuerySorting = props.updateQuerySorting;
    _this.setInitialState = props.setInitialState;

    _this.options.forEach(function (option) {
      return option['value'] = _this._computeValue(option.sortBy, option.sortOrder);
    }); // compute default value for sort field and sort order


    var defaultValue = _this.options.find(function (option) {
      return 'default' in option && option.default;
    });

    _this.defaultValue = {
      sortBy: defaultValue.sortBy || _this.options[0].sortBy,
      sortOrder: defaultValue.sortOrder || _this.options[0].sortOrder
    };

    var defaultValueOnEmptyString = _this.options.find(function (option) {
      return 'defaultOnEmptyString' in option && option.defaultOnEmptyString;
    });

    _this.defaultValueOnEmptyString = {
      sortBy: defaultValueOnEmptyString ? defaultValueOnEmptyString.sortBy : _this.options[0].sortBy,
      sortOrder: defaultValueOnEmptyString ? defaultValueOnEmptyString.sortOrder : _this.options[0].sortOrder
    };
    return _this;
  }

  _createClass(Sort, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentSortBy === null && this.props.currentSortOrder === null) {
        var defaultValue = this.props.currentQueryString ? this.defaultValue : this.defaultValueOnEmptyString;
        this.setInitialState({
          sortBy: defaultValue.sortBy,
          sortOrder: defaultValue.sortOrder
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentSortBy = _this$props.currentSortBy,
          currentSortOrder = _this$props.currentSortOrder,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          label = _this$props.label,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: currentSortBy !== null && currentSortOrder !== null && !loading && totalResults > 0
      }, label( /*#__PURE__*/React.createElement(Element$e, {
        currentSortBy: currentSortBy,
        currentSortOrder: currentSortOrder,
        options: this.options,
        onValueChange: this.onChange,
        computeValue: this._computeValue,
        overridableId: overridableId
      })));
    }
  }]);

  return Sort;
}(Component);

Sort.defaultProps = {
  currentSortBy: null,
  currentSortOrder: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ''
};

var Element$e = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentSortBy = props.currentSortBy,
      currentSortOrder = props.currentSortOrder,
      options = props.options,
      onValueChange = props.onValueChange,
      computeValue = props.computeValue;
  var selected = computeValue(currentSortBy, currentSortOrder);

  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('Sort.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Dropdown, {
    selection: true,
    compact: true,
    options: _options,
    value: selected,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    }
  }));
};

var SortComponent = Overridable.component('Sort', Sort);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$9 = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySorting: function updateQuerySorting$1(sortBy, sortOrder) {
      return dispatch(updateQuerySorting(sortBy, sortOrder));
    },
    setInitialState: function setInitialState$1(value) {
      return dispatch(setInitialState(value));
    }
  };
};

var Sort$1 = connectExtended(function (state) {
  return {
    currentQueryString: state.query.queryString,
    currentSortBy: state.query.sortBy,
    currentSortOrder: state.query.sortOrder,
    loading: state.results.loading,
    totalResults: state.results.data.total
  };
}, mapDispatchToProps$9)(SortComponent);

var SortBy = /*#__PURE__*/function (_Component) {
  _inherits(SortBy, _Component);

  var _super = _createSuper(SortBy);

  function SortBy(props) {
    var _this;

    _classCallCheck(this, SortBy);

    _this = _super.call(this, props);

    _this.onChange = function (value) {
      if (value === _this.props.currentSortBy) return;

      _this.updateQuerySortBy(value);
    };

    _this.options = props.values;
    _this.defaultValue = _this.props.defaultValue;
    _this.defaultValueOnEmptyString = _this.props.defaultValueOnEmptyString;
    _this.updateQuerySortBy = props.updateQuerySortBy;
    _this.setInitialState = props.setInitialState;
    return _this;
  }

  _createClass(SortBy, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentSortBy === null) {
        var sortBy = this.props.currentQueryString ? this.defaultValue : this.defaultValueOnEmptyString || this.defaultValue;
        this.setInitialState({
          sortBy: sortBy
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentSortBy = _this$props.currentSortBy,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          label = _this$props.label,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: currentSortBy !== null && !loading && totalResults > 0
      }, label( /*#__PURE__*/React.createElement(Element$f, {
        currentSortBy: currentSortBy,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId
      })));
    }
  }]);

  return SortBy;
}(Component);

SortBy.defaultProps = {
  defaultValueOnEmptyString: null,
  currentSortBy: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ''
};

var Element$f = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentSortBy = props.currentSortBy,
      options = props.options,
      onValueChange = props.onValueChange;

  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('SortBy.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Dropdown, {
    selection: true,
    compact: true,
    options: _options,
    value: currentSortBy,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    }
  }));
};

var SortByComponent = Overridable.component('SortBy', SortBy);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$a = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySortBy: function updateQuerySortBy$1(sortByValue) {
      return dispatch(updateQuerySortBy(sortByValue));
    },
    setInitialState: function setInitialState$1(value) {
      return dispatch(setInitialState(value));
    }
  };
};

var SortBy$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentSortBy: state.query.sortBy,
    currentQueryString: state.query.queryString
  };
}, mapDispatchToProps$a)(SortByComponent);

var SortOrder = /*#__PURE__*/function (_Component) {
  _inherits(SortOrder, _Component);

  var _super = _createSuper(SortOrder);

  function SortOrder(props) {
    var _this;

    _classCallCheck(this, SortOrder);

    _this = _super.call(this, props);

    _this.onChange = function (value) {
      if (value === _this.props.currentSortOrder) return;

      _this.updateQuerySortOrder(value);
    };

    _this.options = props.values;
    _this.defaultValue = _this.props.defaultValue;
    _this.updateQuerySortOrder = props.updateQuerySortOrder;
    _this.setInitialState = props.setInitialState;
    return _this;
  }

  _createClass(SortOrder, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.currentSortOrder === null) {
        this.setInitialState({
          sortOrder: this.defaultValue
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentSortOrder = _this$props.currentSortOrder,
          loading = _this$props.loading,
          totalResults = _this$props.totalResults,
          label = _this$props.label,
          overridableId = _this$props.overridableId;
      return /*#__PURE__*/React.createElement(ShouldRender$1, {
        condition: currentSortOrder !== null && !loading && totalResults > 0
      }, label( /*#__PURE__*/React.createElement(Element$g, {
        currentSortOrder: currentSortOrder,
        options: this.options,
        onValueChange: this.onChange,
        overridableId: overridableId
      })));
    }
  }]);

  return SortOrder;
}(Component);

SortOrder.defaultProps = {
  currentSortOrder: null,
  label: function label(cmp) {
    return cmp;
  },
  overridableId: ''
};

var Element$g = function Element(_ref) {
  var overridableId = _ref.overridableId,
      props = _objectWithoutProperties(_ref, ["overridableId"]);

  var currentSortOrder = props.currentSortOrder,
      options = props.options,
      onValueChange = props.onValueChange;

  var _options = options.map(function (element, index) {
    return {
      key: index,
      text: element.text,
      value: element.value
    };
  });

  return /*#__PURE__*/React.createElement(Overridable, Object.assign({
    id: buildUID('SortOrder.element', overridableId)
  }, props), /*#__PURE__*/React.createElement(Dropdown, {
    selection: true,
    compact: true,
    options: _options,
    value: currentSortOrder,
    onChange: function onChange(e, _ref2) {
      var value = _ref2.value;
      return onValueChange(value);
    }
  }));
};

var SortOrderComponent = Overridable.component('SortOrder', SortOrder);

/*
 * This file is part of React-SearchKit.
 * Copyright (C) 2018 CERN.
 *
 * React-SearchKit is free software; you can redistribute it and/or modify it
 * under the terms of the MIT License; see LICENSE file for more details.
 */

var mapDispatchToProps$b = function mapDispatchToProps(dispatch) {
  return {
    updateQuerySortOrder: function updateQuerySortOrder$1(sortOrderValue) {
      return dispatch(updateQuerySortOrder(sortOrderValue));
    },
    setInitialState: function setInitialState$1(value) {
      return dispatch(setInitialState(value));
    }
  };
};

var SortOrder$1 = connectExtended(function (state) {
  return {
    loading: state.results.loading,
    totalResults: state.results.data.total,
    currentSortOrder: state.query.sortOrder
  };
}, mapDispatchToProps$b)(SortOrderComponent);

function withState(Component) {
  var WrappedComponent = function WrappedComponent(_ref) {
    var dispatch = _ref.dispatch,
        props = _objectWithoutProperties(_ref, ["dispatch"]);

    return /*#__PURE__*/React.createElement(Component, props);
  };

  var mapStateToProps = function mapStateToProps(state) {
    return {
      currentQueryState: state.query,
      currentResultsState: state.results
    };
  };

  var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
      updateQueryState: function updateQueryState(queryState) {
        return dispatch(updateQueryState$1(queryState));
      }
    };
  };

  return connectExtended(mapStateToProps, mapDispatchToProps)(WrappedComponent);
}

var onQueryChanged = function onQueryChanged(payload) {
  var evt = new CustomEvent('queryChanged', {
    detail: payload
  });
  window.dispatchEvent(evt);
};

export { ActiveFilters$1 as ActiveFilters, AutocompleteSearchBar$1 as AutocompleteSearchBar, BucketAggregation$1 as BucketAggregation, Count$1 as Count, ESRequestSerializer, ESResponseSerializer, ESSearchApi, EmptyResults$1 as EmptyResults, Error$2 as Error, InvenioRequestSerializer, InvenioResponseSerializer, InvenioSearchApi, InvenioSuggestionApi, LayoutSwitcher$1 as LayoutSwitcher, Pagination$1 as Pagination, ReactSearchKit$1 as ReactSearchKit, ResultsGrid$1 as ResultsGrid, ResultsList$1 as ResultsList, ResultsLoader$1 as ResultsLoader, ResultsMultiLayout$1 as ResultsMultiLayout, ResultsPerPage$1 as ResultsPerPage, SearchBar$1 as SearchBar, Sort$1 as Sort, SortBy$1 as SortBy, SortOrder$1 as SortOrder, UrlHandlerApi, configureStore, connectExtended as connect, onQueryChanged, withState };
//# sourceMappingURL=index.js.map
